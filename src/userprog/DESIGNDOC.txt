+---------------------------+
|		CS 140              		|
| PROJECT 2: USER PROGRAMS	|
| 	   DESIGN DOCUMENT     	|
+---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Thanaphat Teeradatchusuk <ice48623@gmail.com>
Soraya Sakonwittayanon <soraya.sakonwittayanon@gmail.com>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

ARGUMENT PASSING
================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

First, slice an input to become one or several arguments by using strtok_r() function.
Arrange element in the order of number, ex: arg[0] is a first argument of the statement and so on.
Lastly, avoid overflowing by check the free space of stack and check number of input arguments,
if number of input argument is grater than a free space in stack, show error.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

Because strtok() buffer is store as global, if many process call strtok() at the same time,
issue arise!! So strtok_r() will solve this problem because buffer is located at local for each process.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1) Reduce workload of kernel
2) More safety of kernel execution.

  SYSTEM CALLS
  ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Added to struct thread:

    struct list children;               /* List of the process' children */


struct child
  {
    struct list_elem elem;              /* List element for a parents children
                                           list.*/
    tid_t tid;                          /* The thread's tid.*/

    int exit_status;                    /* The thread's exit status,
                                           initialized to -1. */
    struct semaphore wait;              /* Semaphore to control waiting*/

    struct semaphore loading_sema;      /* Semaphore to announce the end of
                                           process loading (both successful or
                                           one which ends with an error). */

    bool loaded_status;                 /* True, if process was loaded
                                           successfully or false otherwise. */

  };


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

When a process open a new file, that new file will contains it own
file descriptor and this file descriptor is also unique within a process.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

For Read:
1) Compare input fd with STDIN_FILENO
1.1) IF match, create a buffer and use loop to take keyboard input by calling input_getc().
2) disable interrupt or using lock
3) For each thread_current(), loop over it file list.
4) IF input fd match fd from fd of a file in a list, then create an int variable to store actual data write and calling file_read()
5) IF input fd didn't match any fd from current thread file list, then enable interrupt or release lock and return ERROR
6) enable interrupt or release lock
7) return int variable that was store number of actual write

For Write:
1) Check whether fd is STDIN_FILENO or STDOUT_FILENO
1.1) IF STDIN_FILENO then, exit(-1)
1.2) IF STDOUT_FILENO, acquire lock and print the content from the buffer.
2) call file_write() to write the content from the buffer into an open file.
3) release locks
4) return actual write byte

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

For a full page:
The smallest number is 1 as we get a page head at the first inspection.
The greatest number can be divided into two cases.
1) If the pages are contiguous, we first get a kernel virtual address that is not a page head.
   Then, we check start and end pointer of a page head. So the greatest number is 2.
2) IF the pages are not contiguous, we need to check a valid access for every address so the greatest number is 4096.

For 2 byte of data:
The smallest number is 1 because the size of kernel virtual address space is actually bigger than a data (2 byte).
So it in this page, no need for other inspection.

The greatest number is 2 if the data is not contiguous because it has to inspect for another byte of data where it is located.

For improvement, we cannot think of any.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

First, find tid in a child struct that was store by current thread.
If not found, that's mean that tid doen't exist or wait() have been called already.
If found, wait until that child process complete its execution and terminated.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

We validate the pointer by using pagedir_get_page() and is_user_vaddr().
Calling pagedir_get_page() to check that the pointer is not null and to ensure that it is valid.
Calling is_user_vaddr() to check that it is a virtual address and located below the PHY_BASE.
Ensuring that the pointer not access the kernel address.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

For each thread, it will have one more semaphore struct.
This semaphore will ensure that it will have proper synchronization.
After process_execute finished it execution, it will return TID of a new process.
Then, parent process will find that TID from it child process list.

To passed back the status, there will be a variable that store child status. The purpose of this
variable is to keep track of whether a child process is still alive or dead, since the kernel might terminate it while execution.
Another thing that will have in child process is a variable that will be set at the end after execution completed. This variable
set success or failed of execution.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

Ensure proper synchronization and avoid race condition by using lock mechanism when p calls wait(C) both before C exits and after C exits.

When P terminated without waiting before C exits, C will become an orphan and will be adopted by init process.
Therefore, all resources of C will be freed due to periodically invoke wait() by init process.
If P terminated without waiting for C after C exits, then C will freed it resources automatically.
P will also freed it resources after finish execution.

No special case so far that we can think of. XD

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

Because it is a simplest way to implement.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Each process was it own file descriptors list, so it avoid a process pull file descriptor of another file descriptor that belongs to another process.

For disadvantage, since each file descriptor is kept in a list, a process will need to spend all looking up
for desired file descriptor which is quite costly because a process can have as many file opened as it want as long as it have enough memory.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We didn't change anything of tid_t to pid_t mapping.

SURVEY QUESTIONS
================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?


>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

Yes, but maybe not that much

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

An overall steps that student should take as a guideline.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
